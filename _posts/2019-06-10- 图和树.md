---
layout: post
title: 图和树
date: 2019-6-10 
tags: Mathematics
---

# 图论

------
```
本文参考----《离散数学第二版》
仅为博主考试复习用
内含大概率例题
侵删
```
**考纲重点**

* 图的模型/欧拉图/哈密顿图
* 树的应用/最小生成树
* 哈夫曼编码

------

# 1) 图

### **图的定义**

![img](/images/posts/lsjg/25.png)

  其中图分为**有向图和无向图**，有向图简而言之就是带箭头的，反之无向图就不是。给定图用G = <V, E> 表示，其中V代表顶点，分别记作vi; E代表边数，分别记作ei。 
  下面有两个重要的名词：**环**和**平行边**。环是指vi->ei->vi;而平行边是指v1->e1->v2和v1->e2->v2。与顶点相关联的边之和我们称之为**度，记作d(v)**。则我们把**环也不含平行边的图称为简单图**。
  
  根据握手原理，可得出以下的结论：
        
* **所有度之和 = 边的两倍**
* **出度和入度相等，都等于边数**
* **max{ d(v) | v = V(G)} 小于等于 n-1**

### **度数列**

![img](/images/posts/lsjg/26.png)


举个栗子：
![img](/images/posts/lsjg/28.png)


### **图的同构**

![img](/images/posts/lsjg/27.png)

举个栗子：
![img](/images/posts/lsjg/29.png)

另外；**子图**就是某个图的一部分；**补图**就是某个图的另一部分；**完全图**就是一个完整的简单图，每个点都与其他n-1歌顶点相连接。

注:图的矩阵表示就自己看书吧2333333；这里只给出两个博主记不住的概念：
![img](/images/posts/lsjg/30.png)
![img](/images/posts/lsjg/31.png)


### **完全图**
![img](/images/posts/lsjg/37.png)

举个重要的栗子：
```
现有n个盒子，
若每两个盒子里都恰有一个颜色的球，
且每种颜色的球恰有两个放在不同的盒子中，
问这n个盒子中共有多少中不同颜色的球。

解：
    把每个盒子看作一个点；
    每两个盒子有一个球----每两个点连一条边
    每个颜色放在连两个盒子----没有平行边
    
    #get:这是一个完全图！！
    #so：边数 = n(n-1)/2 = 颜色个数
```


### **欧拉图**

欧拉图想必大家都不陌生，能一笔画的就是欧拉图，一笔画回不到原点的就是半欧拉图。
下面给出如下定理：

> * 无向图G是欧拉图当且仅当G是连通图，且G中只有偶度顶点
> * 无向图是半欧拉图当且仅当G是连通图，且G中恰好有两个奇度点
> * 删除一条边v得到非连通图，则称这条边为桥

根据定理，我们得出一个算法：

![img](/images/posts/lsjg/32.png)


接下来就是练习的时间了：
例一：
![img](/images/posts/lsjg/33.png)

例二：
![img](/images/posts/lsjg/34.png)![img](/images/posts/lsjg/35.png)

例三：
![img](/images/posts/lsjg/36.png)

### **哈密顿图**

哈密顿图就是每个顶点有且仅有一次的通路为**哈密顿通路**，而最后回到原点的就是**哈密顿回路**。
其中哈密顿图的判定方法是（具体见P217）：找一类相隔的点记作A，另一类记作B，若A=B，则该图为哈密顿图，否则就是半哈密顿图。

--------

# 树

### **树的定义**
**树**是没有简单回路的联通无向图，多颗树叫做**森林**；其中有如下的性质：

* m = n-1；      n为阶数，m为边数

### **最小生成树**
一个图就能解释了：其实也就是找到权值和最小的一条路径。
![img](/images/posts/lsjg/38.png)

接下来就要介绍两个必考的算法了！他们都是用来求出最小生成树的算法，有兴趣的同学可以拿编程实现一些哦
> * Kruskal算法
> * Prim算法

其定义如下：
![img](/images/posts/lsjg/39.png)![img](/images/posts/lsjg/40.png)
![img](/images/posts/lsjg/41.png)![img](/images/posts/lsjg/42.png)

好啦，让我们举个栗子：
![img](/images/posts/lsjg/43.png)

### **哈夫曼树**
最后一点内容了，坚持住！这是**哈夫曼树**的定义：
![img](/images/posts/lsjg/44.png)

哈夫曼树的构造方法太复杂了，因为篇幅有限就不多说了，我们举几个简单的栗子就大概明白了！
![img](/images/posts/lsjg/45.png)
看这到例题，从下往上把每个最小的给连起来，构成一个wpl最小的树，是不是很简单？还没明白的画，我们多看几个就懂了。
![img](/images/posts/lsjg/46.png)

现在我们开始把哈夫曼树进行编码，我们规定**左子树为0，右子树为1**
![img](/images/posts/lsjg/47.png)


好啦，接下来就是一道经典的栗子：
![img](/images/posts/lsjg/48.png)
![img](/images/posts/lsjg/49.png)
![img](/images/posts/lsjg/50.png)

----------
## 结语

到此，我们图论就复习的差不多了，剩下未讲到的知识点---红黑树，完全二叉树等等都在下学期数据结构中有所体现，大家暑假有时间记得可以拿编程实现一下哦！祝大家考试顺利。


* 作者：ZiChuan Liu
* 邮箱: 775269512@qq.com
* 博客: [我的博客](https://775269512.github.io/)

